import logging
import os
import time

import altair
import geopandas
import pandas

from natcap.invest import gettext
import natcap.invest.spec
from natcap.invest.reports import jinja_env


LOGGER = logging.getLogger(__name__)

TEMPLATE = jinja_env.get_template('models/coastal_vulnerability.html')

STROKE_WIDTH = 0.75
# When points are low-density, fill is nicer, or a thicker stroke.
# But when high-density, there's too much overplotting
# and no fill is better with a thinner stroke
# TODO: solve for this somehow? Or add a widget?
POINT_FILL = False
if not POINT_FILL:
    STROKE_WIDTH = 1.5

POINT_SIZE = 20
MAP_WIDTH = 450  # pixels

LEGEND_CONFIG = {
    'labelFontSize': 14,
    'titleFontSize': 14,
    'orient': 'left',
    'gradientLength': 120
}
AXIS_CONFIG = {
    'labelFontSize': 12,
    'titleFontSize': 12,
}


def _get_geojson_bbox(geodataframe):
    """Get the bounding box of a GeoDataFrame as a GeoJSON feature.

    Also calculate its aspect ratio. These are useful for cropping
    other layers in altair plots.

    Args:
        geodataframe (geopandas.GeoDataFrame):
    Returns:
        tuple: A 2-tuple containing:
            - extent_feature (dict): A GeoJSON feature representing the bounding
            box of the input GeoDataFrame.
            - xy_ratio (float): The aspect ratio of the bounding box
            (width/height).

    """
    xmin, ymin, xmax, ymax = geodataframe.total_bounds
    xy_ratio = (xmax - xmin) / (ymax - ymin)
    extent_feature = {
        "type": "Feature",
        "geometry": {"type": "Polygon",
                     "coordinates": [[
                         [xmax, ymax],
                         [xmax, ymin],
                         [xmin, ymin],
                         [xmin, ymax],
                         [xmax, ymax]]]},
        "properties": {}
    }
    return extent_feature, xy_ratio


def _chart_landmass(geodataframe, clip=False, extent_feature=None):
    landmass = altair.Chart(geodataframe).mark_geoshape(
        clip=clip,
        fill='lightgrey'
    ).project(
        type='identity',
        reflectY=True,  # Canvas and SVG treats positive y as down
        fit=extent_feature
    )
    return landmass


def _chart_base_points(geodataframe):
    # Plot points using mark_circle instead of mark_geoshape
    # so that they can get a size encoding later if needed.
    base_points = altair.Chart(
        geodataframe
    ).transform_calculate(
        lon="datum.geometry.coordinates[0]",
        lat="datum.geometry.coordinates[1]",
    ).project(
        type='identity',
        reflectY=True  # Canvas and SVG treats positive y as down
    ).mark_circle().encode(
        longitude='lon:Q',
        latitude='lat:Q',
    )
    return base_points


def _chart_habitat_map(habitat_protection_csv, exposure_geodf, landmass_chart):
    habitat_df = pandas.read_csv(habitat_protection_csv)
    habitat_geodf = exposure_geodf[['shore_id', 'geometry', 'habitat_role']].join(
        habitat_df.set_index('shore_id'), on='shore_id')
    habitats = set(habitat_df.columns).difference(set(['shore_id', 'R_hab']))

    def concat_habitats(row):
        hab_list = []
        for h in habitats:
            if row[h] != 5:  # 5 is the model's code for no habitat present
                hab_list.append(h)
        return ','.join(hab_list)
    habitat_geodf['hab_presence'] = habitat_geodf.apply(concat_habitats, axis=1)

    habitat_base_points = _chart_base_points(habitat_geodf)
    habitat_points = habitat_base_points.mark_circle(
        filled=POINT_FILL,
        strokeWidth=STROKE_WIDTH,
        size=POINT_SIZE
    ).encode(
        color=altair.Color('habitat_role').scale(scheme='viridis', reverse=True),
        tooltip=[
            {
                'field': 'habitat_role',
                'format': '.2f'
            },
            {
                'field': 'hab_presence'
            }
        ]
    )

    _, xy_ratio = _get_geojson_bbox(exposure_geodf)
    habitat_map = landmass_chart + habitat_points
    habitat_map = habitat_map.properties(
        width=MAP_WIDTH,
        height=MAP_WIDTH / xy_ratio,
        title=gettext('The role of habitat in reducing coastal exposure')
    ).configure_legend(**LEGEND_CONFIG).configure_axis(**AXIS_CONFIG)
    return habitat_map


def report(file_registry, args_dict, model_spec, target_html_filepath):
    """Generate an html summary of Coastal Vulnerability results.

    Args:
        file_registry (dict): The ``natcap.invest.FileRegistry.registry``
            that was returned by ``natcap.invest.coastal_vulnerability.execute``.
        args_dict (dict): The arguments that were passed to
            ``natcap.invest.coastal_vulnerability.execute``.
        model_spec (natcap.invest.spec.ModelSpec):
            ``natcap.invest.coastal_vulnerability.MODEL_SPEC``
        target_html_filepath (str): path to an html file generated by this
            function.

    Returns:
        None
    """
    images_dir = os.path.join(args_dict['workspace_dir'], '_images')
    if not os.path.exists(images_dir):
        os.mkdir(images_dir)

    rank_vars = ['R_hab', 'R_wind', 'R_wave', 'R_surge', 'R_relief']
    exposure_geo = geopandas.read_file(file_registry['coastal_exposure'])
    if 'R_geomorph' in exposure_geo:
        rank_vars.append('R_geomorph')
    tooltip_vars = ['exposure'] + rank_vars

    landmass_geo = geopandas.read_file(
        file_registry['clipped_projected_landmass'])
    extent_feature, xy_ratio = _get_geojson_bbox(exposure_geo)
    landmass_chart = _chart_landmass(
        landmass_geo, clip=True, extent_feature=extent_feature)
    base_points = _chart_base_points(exposure_geo)

    scale_population = altair.param(value=False)
    if 'population' in exposure_geo:
        # Population is used to scale point size in exposure maps,
        # but it is an optional input to the model.
        # If population is missing we still want to plot the point.
        exposure_geo.population = exposure_geo.population.fillna(-1)
        tooltip_vars.append('population')
        population_spec = model_spec.get_output(
            'coastal_exposure').get_field('population')
        population_checkbox = altair.binding_checkbox(
            name=(f"{gettext('scale by population')} "
                  f"({natcap.invest.spec.format_unit(population_spec.units)})")
        )
        scale_population = altair.param(value=False, bind=population_checkbox)
        population_caption = population_spec.about + gettext("""
             '-1' represents no valid population data within the search radius
            around a point.""")

    tooltip = altair.Tooltip(tooltip_vars, format='.2f')

    point_size_conditional = altair.condition(
        scale_population,
        'population:Q',
        altair.value(POINT_SIZE))

    exposure_points_chart = base_points.transform_filter(
        altair.expr.isValid(altair.datum.exposure)
    ).mark_circle(
        filled=POINT_FILL,
        strokeWidth=STROKE_WIDTH,
    ).encode(
        size=point_size_conditional,
        color=altair.Color(
            'exposure',
            legend=altair.Legend(
                title='exposure',
                values=[1, 2, 3, 4, 5],  # force these values and labels
                labelExpr="datum.value",  # value refers to the list above.
            )
        ).scale(scheme='plasma', reverse=True).bin(extent=[1.0, 5.0]),
        tooltip=tooltip
    ).add_params(scale_population)

    na_count = exposure_geo.exposure.isna().sum()
    if na_count:
        null_checkbox = altair.binding_checkbox(
            name=(f"{na_count} "
                  f"{gettext('point(s) missing the exposure index. Show:')}"))
        show_null = altair.param(value=False, bind=null_checkbox)
        null_points_chart = base_points.add_params(
            show_null
        ).transform_filter(
            show_null & ~altair.expr.isValid(altair.datum.exposure)
        ).mark_point(
            shape='M-1, -1, L1, 1, M-1, 1, L1, -1',  # an X
            stroke='black',
            strokeWidth=1.5,
            invalid='show',
            size=36,
        ).encode(
            tooltip=tooltip
        )
        exposure_map = landmass_chart + null_points_chart + exposure_points_chart
    else:
        exposure_map = landmass_chart + exposure_points_chart

    exposure_map = exposure_map.properties(
        width=MAP_WIDTH,
        height=MAP_WIDTH / xy_ratio,
        title='coastal exposure'
    ).configure_legend(**LEGEND_CONFIG)
    exposure_map_json = exposure_map.to_json()
    exposure_map_caption = [model_spec.get_output(
        'coastal_exposure').get_field('exposure').about]
    if population_caption:
        exposure_map_caption.append(population_caption)
    exposure_map_source_list = [
        model_spec.get_output('coastal_exposure').path,
        model_spec.get_output('clipped_projected_landmass').path]

    habitat_map = _chart_habitat_map(
        file_registry['habitat_protection'],
        exposure_geo,
        landmass_chart)
    habitat_map_json = habitat_map.to_json()
    habitat_map_caption = model_spec.get_output(
        'coastal_exposure').get_field('habitat_role').about
    habitat_map_source_list = [
        model_spec.get_output('coastal_exposure').path,
        model_spec.get_output('habitat_protection').path]

    habitat_params_df = pandas.read_csv(args_dict['habitat_table_path'])
    about_habitat_rank = model_spec.get_input(
        'habitat_table_path').get_column('rank').about
    habitat_table_caption = f'Rank = {about_habitat_rank}'
    habitat_table_source_list = [args_dict['habitat_table_path']]

    exposure_histogram = altair.Chart(exposure_geo).mark_bar().encode(
        x=altair.X('exposure', title='coastal exposure').bin(step=0.2),
        y='count()',
        color=altair.Color(
            'exposure',
            legend=None,
        ).scale(scheme='plasma', reverse=True).bin(maxbins=4)
    ).properties(
        width=MAP_WIDTH,
        height=200
    ).configure_axis(**AXIS_CONFIG)
    exposure_histogram_json = exposure_histogram.to_json()

    base_rank_vars_chart = base_points.mark_circle(
        filled=POINT_FILL,
        strokeWidth=STROKE_WIDTH,
        size=POINT_SIZE
    )
    rank_vars_chart_list = []
    for var in rank_vars:
        point_chart = base_rank_vars_chart.encode(
            color=altair.Color(
                f'{var}',
                legend=altair.Legend(title='rank')
            ).scale(scheme='plasma', reverse=True),
        )
        rank_vars_chart_list.append(
            altair.layer(landmass_chart, point_chart).properties(
                title=var))

    n_cols = len(rank_vars) // 2
    rank_vars_figure = altair.vconcat(
        altair.hconcat(*rank_vars_chart_list[:n_cols]),
        altair.hconcat(*rank_vars_chart_list[n_cols:])
    ).configure_axis(**AXIS_CONFIG)
    rank_vars_figure_json = rank_vars_figure.to_json()
    rank_vars_figure_caption = gettext(
        """
        These variables are the individual components of the coastal exposure index.
        The exposure index is calculated as the geometric mean of these variables.
        If a shore point is missing data about one of these variables, then the
        exposure index will also be missing at that point.
        """)
    rank_vars_figure_source_list = [model_spec.get_output('coastal_exposure').path]

    csv_spec = model_spec.get_output('intermediate_exposure_csv')
    intermediate_vars = ['relief', 'wind', 'wave', 'surge']
    units = [natcap.invest.spec.format_unit(csv_spec.get_column(var).units)
             for var in intermediate_vars]
    renamed_vars = [f'{var} {u}'
                    for var, u in zip(intermediate_vars, units)]
    intermediate_df = pandas.read_csv(file_registry['intermediate_exposure_csv'])
    variable_label_lookup = {var: new_var for var, new_var
                             in zip(intermediate_vars, renamed_vars)}
    intermediate_df.rename(
        columns=variable_label_lookup, inplace=True)
    histograms = []
    for i, var in enumerate(renamed_vars):
        # remove redundant axis titles
        title = gettext('Count of Records') if i == 0 else None
        hist = altair.Chart(intermediate_df).mark_bar().encode(
            altair.X(
                var,
                type='quantitative',
                bin=altair.Bin(nice=True)),
            y=altair.Y('count()', title=title)
        ).properties(
            width=MAP_WIDTH // 2
        )
        histograms.append(hist)
    facetted_histograms = altair.hconcat(
        *histograms).configure_axis(**AXIS_CONFIG)
    facetted_histograms_json = facetted_histograms.to_json()
    facetted_histograms_caption = model_spec.get_output(
        'intermediate_exposure').about
    facetted_histograms_source_list = [model_spec.get_output(
        'intermediate_exposure').path]

    wave_energy_geo = geopandas.read_file(file_registry['wave_energies'])
    wave_var = variable_label_lookup['wave']
    wave_energy_geo = wave_energy_geo.join(
        intermediate_df[['shore_id', wave_var]].set_index(
            'shore_id'), on='shore_id')
    wave_checkbox = altair.binding_checkbox(name=gettext('scale by wave energy'))
    scale_wave = altair.param(value=False, bind=wave_checkbox)
    point_size_conditional = altair.condition(
        scale_wave,
        f'{wave_var}:Q',
        altair.value(POINT_SIZE))

    base_wave_points = _chart_base_points(wave_energy_geo)
    wave_points_chart = base_wave_points.mark_circle(
        filled=POINT_FILL,
        strokeWidth=STROKE_WIDTH,
    ).encode(
        color=altair.Color(
            'max_E_type:N',
            legend=altair.Legend(title=gettext('dominant wave type'))
        ),
        size=point_size_conditional
    ).add_params(scale_wave)
    wave_energy_map = landmass_chart + wave_points_chart
    wave_energy_map = wave_energy_map.properties(
        width=MAP_WIDTH + 30,  # extra space for legend
        height=MAP_WIDTH / xy_ratio,
        title=gettext('local wind-driven waves vs. open ocean waves')
    ).configure_legend(**LEGEND_CONFIG)
    wave_energy_map_json = wave_energy_map.to_json()

    wave_energy_map_caption = [model_spec.get_output(
        'wave_energies').about]
    wave_energy_map_caption.append(
        model_spec.get_input('max_fetch_distance').about)
    wave_energy_map_source_list = [
        model_spec.get_output('wave_energies').path,
        model_spec.get_output('intermediate_exposure').path]

    # Generate HTML document.
    model_name = model_spec.model_title

    with open(target_html_filepath, 'w', encoding='utf-8') as target_file:
        target_file.write(TEMPLATE.render(
            report_script=__file__,
            timestamp=time.strftime('%Y-%m-%d %H:%M'),
            model_id=model_spec.model_id,
            model_name=model_name,
            model_description=model_spec.about,
            userguide_page=model_spec.userguide,
            args_dict=args_dict,
            exposure_map_json=exposure_map_json,
            exposure_map_caption=exposure_map_caption,
            exposure_map_source_list=exposure_map_source_list,
            habitat_map_json=habitat_map_json,
            habitat_map_caption=habitat_map_caption,
            habitat_map_source_list=habitat_map_source_list,
            habitat_params_table=habitat_params_df.to_html(),
            habitat_table_caption=habitat_table_caption,
            habitat_table_source_list=habitat_table_source_list,
            exposure_histogram_json=exposure_histogram_json,
            facetted_histograms_json=facetted_histograms_json,
            facetted_histograms_caption=facetted_histograms_caption,
            facetted_histograms_source_list=facetted_histograms_source_list,
            rank_vars_figure_json=rank_vars_figure_json,
            rank_vars_figure_caption=rank_vars_figure_caption,
            rank_vars_figure_source_list=rank_vars_figure_source_list,
            wave_energy_map_json=wave_energy_map_json,
            wave_energy_map_caption=wave_energy_map_caption,
            wave_energy_map_source_list=wave_energy_map_source_list,
            model_spec_outputs=model_spec.outputs,
        ))
    LOGGER.info(f'Created {target_html_filepath}')
